<div dir="rtl">

# نقاشی بکش لویی (بخش دوم) - تمرین دستگرمی سوم برنامه نویسی وب

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Sharif-University-of-Technology.jpg" alt="لوگوی دانشگاه صنعتی شریف" width="200">
</p>

<p align="center">
  <b>دانشگاه صنعتی شریف</b><br>
  دانشکده مهندسی کامپیوتر<br>
  درس برنامه‌نویسی وب - بهار ۱۴۰۴
  <br>استاد درس: دکتر یحیی پورسلطانی
</p>

<p align="center">
  <b>علی هاشمیان</b><br>
  شماره دانشجویی: ۴۰۱۱۰۶۶۸۵
</p>

---

### ۱. قابلیت‌های کلیدی برنامه

*   امکان طراحی نقاشی با کشیدن و رها کردن (drag & drop) اشکال از نوار ابزار.
*   قابلیت جابجایی اشکال کشیده شده در هر نقطه از بوم طراحی.
*   حذف یک شکل با دو بار کلیک کردن (double-click) بر روی آن.
*   امکان ویرایش و تغییر عنوان نقاشی به صورت مستقیم در هدر برنامه.
*   وجود شمارشگر زنده برای نمایش تعداد هر یک از اشکال موجود.
*   پیاده‌سازی یک سرور بک‌اند با Spring Boot جهت مدیریت کامل داده‌ها.
*   قابلیت تفکیک کاربران و ذخیره یک نقاشی منحصر به فرد برای هر کاربر.
*   ذخیره‌سازی دائمی داده‌ها در یک پایگاه داده H2 مبتنی بر فایل.
*   بارگذاری خودکار نقاشی کاربر از سرور با انتخاب او از منوی dropdown.
*   ذخیره وضعیت فعلی نقاشی روی سرور از طریق یک API با متد PUT.
*   استفاده از فرمت JSON برای ذخیره‌سازی ساختاریافته اطلاعات اشکال در دیتابیس.
*   ایجاد خودکار کاربران پیش‌فرض هنگام راه‌اندازی سرور برای سهولت در تست.




### ۲. نحوه عملکرد کلی سیستم

*   فرانت‌اند برنامه که با React توسعه داده شده، مسئولیت کامل رابط کاربری را بر عهده دارد و تمام تعاملات کاربر، از جمله drag & drop اشکال و کلیک روی دکمه‌ها را مدیریت می‌کند.
*   ارتباط بین دو بخش از طریق درخواست‌های HTTP به یک REST API برقرار می‌شود. این درخواست‌ها در فرانت‌اند، به طور متمرکز در فایل `PaintingContext.tsx` و با استفاده از تابع `fetch` ارسال می‌شوند.
*   بک‌اند که با Spring Boot پیاده‌سازی شده، این درخواست‌ها را از طریق یک `RestController` دریافت می‌کند و بر اساس نوع درخواست (GET برای خواندن و PUT برای نوشتن)، اندپوینت (endpoint) مربوطه فعال می‌شود.
*   پس از دریافت داده، بک‌اند منطق برنامه را اجرا می‌کند؛ برای مثال، اطلاعات نقاشی را به فرمت JSON تبدیل کرده و در دیتابیس H2 ذخیره می‌کند. این فرآیند با کمک لایه‌های Service و Repository مدیریت می‌شود تا کد تمیز و قابل نگهداری باشد.


### ۳. پیاده‌سازی و شرح کد

بخش سرور با معماری لایه‌ای در فریمورک Spring Boot توسعه یافته که شرح فایل‌های کلیدی آن در ادامه آمده است.

*   فایل `PaintingController.java` به عنوان دروازه ورودی برنامه، مسئولیت دریافت درخواست‌های HTTP و تعریف اندپوینت‌های API را بر عهده دارد.
*   کلاس `PaintingService.java` مغز اصلی و مرکز منطق برنامه محسوب می‌شود و وظایفی چون تبدیل داده به فرمت JSON را انجام می‌دهد.
*   کلاس‌های `User.java` و `Painting.java` موجودیت‌های اصلی یا همان Entities ما هستند که ساختار جداول دیتابیس را مشخص می‌کنند.
*   اینترفیس‌های `UserRepository` و `PaintingRepository` ابزار ارتباط ما با پایگاه داده هستند و عملیات دیتابیس را بدون نیاز به کد SQL ممکن می‌سازند.
*   کلاس‌های `PaintingDto.java` و `ShapeDto.java` به عنوان اشیاء انتقال داده، ساختار اطلاعات رد و بدل شده بین کلاینت و سرور را تعریف می‌کنند.
*   فایل `WebConfig.java` برای انجام تنظیمات مربوط به CORS استفاده شده است تا فرانت‌اند بتواند به APIهای بک‌اند دسترسی داشته باشد.
*   کلاس `DataLoader.java` یک ابزار کمکی برای راه‌اندازی اولیه است و وظیفه دارد هنگام شروع به کار سرور، کاربران پیش‌فرض را ایجاد نماید.



    
### ۴. چالش‌ها و تصمیمات طراحی

*   پروژه با چالش فنی پیچیده‌ای روبرو نبود، اما تصمیمات طراحی مهمی در طول آن گرفته شد.
*   یک تصمیم کلیدی، حذف قابلیت‌های import و export از نسخه قبل بود؛ زیرا هدف این فاز پیاده‌سازی ذخیره‌سازی سمت سرور و متمرکز برای هر کاربر بود.
*   یک چالش طراحی، نحوه ذخیره‌سازی ساختار پیچیده اشکال در دیتابیس بود که تصمیم گرفته شد کل داده به صورت یک رشته JSON در یک ستون ذخیره شود.
*   این روش پیاده‌سازی را ساده‌تر می‌کند اما در آینده، کوئری زدن بر اساس ویژگی‌های خاص هر شکل را دشوارتر می‌سازد.



### ۵. استفاده از هوش مصنوعی در پروژه

در این تمرین، از ابزارهای هوش مصنوعی به عنوان یک **دستیار برنامه‌نویس (AI Assistant)** و نه به عنوان انجام‌دهنده کامل پروژه، استفاده شد. هدف اصلی، افزایش سرعت در انجام کارهای تکراری و کمک به یادگیری مفاهیم جدید بود. نحوه استفاده، مزایا و معایب آن در ادامه شرح داده می‌شود.

#### نحوه استفاده

استفاده از هوش مصنوعی محدود به وظایف مشخص و تعریف‌شده‌ای بود که به شرح زیر است:

*   **ایجاد ساختار اولیه پروژه:** برای تولید ساختار اولیه پروژه Spring Boot و وابستگی‌های مورد نیاز در فایل `pom.xml` از هوش مصنوعی کمک گرفته شد.
*   **تولید کدهای تکراری (Boilerplate):** برای ایجاد ساختار اولیه کلاس‌ها مانند `PaintingController` و `PaintingService` یا مدل‌های `Entity`، یک درخواست کلی به هوش مصنوعی داده می‌شد و سپس منطق اصلی و جزئیات آن به صورت دستی تکمیل می‌گردید.
*   **کمک در دیباگ کردن خطاها:** یکی از کاربردهای اصلی، ارائه پیام‌های خطا به هوش مصنوعی و درخواست توضیح در مورد دلیل خطا بود. به خصوص در فهم خطاهای کامپایل جاوا مانند خطای مربوط به `import` های فراموش شده، این روش بسیار مؤثر بود.
*   **کمک در نوشتن و ساختاربندی مستندات:** برای نوشتن و بهبود ساختار بخش‌هایی از همین فایل `README.md` از هوش مصنوعی کمک گرفته شد تا متن نهایی خواناتر و حرفه‌ای‌تر باشد.

#### مزایا

*   **افزایش چشمگیر سرعت:** مهم‌ترین مزیت، صرفه‌جویی در زمان بود. تولید خودکار کدهای تکراری و ساختارهای اولیه، فرآیند توسعه را به شکل قابل توجهی سرعت بخشید.
*   **ابزاری برای یادگیری سریع:** وقتی با یک خطا یا مفهوم جدید مانند پیکربندی CORS مواجه می‌شدم، توضیحات هوش مصنوعی به درک سریع‌تر دلیل و راه‌حل آن کمک می‌کرد و به نوعی نقش یک معلم خصوصی را ایفا می‌کرد.
*   **تمرکز بر منطق اصلی:** با واگذاری کارهای روتین به هوش مصنوعی، تمرکز ذهنی بیشتری برای طراحی و پیاده‌سازی منطق اصلی برنامه در لایه `Service` باقی می‌ماند.

#### معایب و چالش‌ها

*   **نیاز به بازبینی و اصلاح دقیق:** بزرگترین چالش، اعتماد کامل به کد تولید شده بود. برای مثال، در ابتدا هوش مصنوعی در نام‌گذاری پکیج‌ها ناهماهنگی ایجاد کرده بود (`paintingapp` در مقابل `painting_app`) که نیاز به بررسی دقیق و اصلاح دستی داشت.
*   **خطر تبدیل شدن به یک جعبه سیاه:** این خطر همیشه وجود دارد که برنامه‌نویس کد تولید شده را بدون درک کامل آن بپذیرد. برای مقابله با این موضوع، لازم بود هر قطعه کد تولید شده را به دقت مطالعه و تحلیل کنم تا از صحت عملکرد و دلیل انتخاب آن ساختار مطمئن شوم.
*   **عمومی بودن راه‌حل‌ها:** گاهی اوقات کدهای پیشنهادی بیش از حد کلی و عمومی بودند و برای منطبق شدن کامل با نیازهای خاص پروژه، نیاز به تغییر و سفارشی‌سازی قابل توجهی داشتند.
